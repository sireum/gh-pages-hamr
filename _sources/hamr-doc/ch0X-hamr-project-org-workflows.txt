.. _ch0X-hamr-project-org-workflows:

HAMR Project Organization and Workflows
############################################

.. contents:: 
   :local: 
   :depth: 2
   
Overview
=================

Using HAMR for end-to-end development involves using several different tools including the Eclipse-based OSATE for developing AADL models, IDEs for code-level development such as IntelliJ (for Slang) or CLion (for C), different translators and compilers.  Many of these tools have their own project configuration files, an associated set of file types, and conventions for organizing project files into folders.   

HAMR also supports different workflows -- depending on (a) the programming language used to code component implementations and (b) the target platform (e.g., JVM, Linux, seL4).

This chapter provides

* suggestions for how to structure a HAMR project into folders/files oriented for the tools used in HAMR workflows,
* summaries of how the project structure may be supported in Git (e.g., which folders/files should be retained in the repository vs. the files that are generated by the tooling and should not be stored), and
* summaries of some of the common HAMR workflows.

Generally, HAMR does not mandate a particular project structure, so the directions in this chapter can be seen as "suggestions" and not "requirements".   In any case, it's recommended that organizations using HAMR adopt a project structure and use it consistently across their HAMR-based development.



Code Organization
==================

The diagram below illustrates the suggested organization of a HAMR project.  High-level aspects of this organization are described below.   Structures of folders that support specific workflows and platforms are described in corresponding HAMR documentation chapters.

.. code-block:: none

   aadl/
   hamr/
   ├── bin/
   ├── src/
       ├── slang/
       └── c/
           ├── <platform infrastructure code folder>/
           |    ├── ...
           |    └── CMAKELists.txt
           |
           └── c-ext/
               ├── <component C1 application code folder>/
               |    ├── <component C1>.c 
               |    ├── <component C1>_api.c 
               |    └── <component C1>_api.h
               ├── ...
               ├── <component Cn application code folder>/
               ├── adapters/
               |    ├── <component C1 mangled name>/
               |    |    ├── <component C1>_adapter.c
               |    |    └── <component C1>_adapter.h
               |    ├── ...
               |    └── <component Cn mangled name>/
               | 
               ├── ext.c
               ├── ext.h 
               └── ipc.c 

`aadl` folder holds files for AADL architectural models, file types for associated AADL tooling such as Alisa or Resolute requirements and verification plans, files supporting analyses, etc.  The folder also includes libraries necessary to support OSATE and its instantiation of Eclipse.




The :file:`<platform infrastructure code folder>` contains HAMR-generated infrastructure code for the chosen platform.   This code should never be modified by the developer -- succesive calls to HAMR code generation will overwrite these files.  

.. note::

   **ToDo, From John, To Jason:** Briefly describe the purpose of the CMAKELists.txt file.  I assume that it is the primary method of configuring the build.  Does the user ever need to modify it?  Does it get overwritten with successive calls to the code generator? 

** CMAKELists.txt is autogenerated.   Jason notes that there are other CMAKELists.txt  The organization of :file:`CMAKELists.txt` and an overview of how to customize it for compilation is presented at the end of this chapter.

Developer-written application code goes in the file:`c-ext` folder, using the subfolders for each AADL thread component.  In the files :file:`<component Cn>.c`, HAMR will generate function skeletons for each thread entry point for the respective AADL thread component (e.g., for the compute entry point, either a `time-triggered` function for `periodic` threads, or input event handlers for `sporadic` threads will be generated) -- all following the same structure as described in Chapter XX **ToDo**.   When the HAMR code generator is called successively, the :file:`<component Cn>.c` files *will not* be overwritten.  

Programming the logic for the component consists of filling in code in the thread entry point skeletons.  This code will typically call functions to send and receive data over AADL ports (defined in the HAMR-generated files :file:`<component C1>_api.h` and :file:`<component C1>_api.c`).   The developer should not modify the :file:`<component C1>_api.h` and :file:`<component C1>_api.c`, and these files *will* be overwritten on successive invocations of HAMR code generation (e.g., the files may be changed to reflect changes to the component's port declarations in the AADL model).

Other C files that support the application may be added (where??? **ToDo** -- Jason complete).

The :file:`adapters/` folder (**ToDo** -- Jason complete)

The :file:`ext.c`, :file:`ext.h`, and :file:`ipc.c` files (**ToDo** -- Jason complete)


.. note::

   **ToDo, From John, To Jason:** 
   
   * Check/complete description of folders/files above.

   * What files contain the macros that simplify the developer's programming?

Use of OSATE/Eclipse Workspace in Conjunction with GIT
========================================================

In general, we assume that HAMR is being used with a source code management tool like GIT.
We don't assume that Eclipse workspace is checked into GIT.  So we will point OSATE at folders destined for GIT control.


Project Set Up 
=====================

Optional: align project with git repository (pointer to advice how to structure project within git, multiple projects within a git repository, etc)  (OS and GIT)
Create folder structure (OS): aadl folder, hamr folder (with source folders according to chosen language)
Create AADL project (OSATE) 
  - New AADL Project
      - name (used as an identifier within OSATE/Eclipse to identify a project -- doesn't show up as a folder name) should be generally be something similar to the top folder name in the tree structure above
      - location should be AADL folder associated with project
  - Set up folder structure within AADL folder (highlight project name/root in AADL Navigator and select New Folder)
      - packages
      - instances
Develop AADL Skeleton Model (OSATE) -- see advice on package structure, etc.  (see subsystem/unit vs system)
  - properties
      - scheduling 
  - type libary
      - HAMR default type -- to be used in initial random simulation 

Initial Model and Random Simulation
=====================================

Develop initial AADL model (OSATE) (code to the point to which initial random simulation will be applied, see HAMR AADL Style Guidelines)
Configure Target Platform (OSATE and external)
  - scheduling, communication 
Run Resolint (OSATE Plugin)
Run HAMR Code Generation (OSATE Plugin)
Configure Simulation -- Initial Component Implementations and Configurations on Platform (Target Language IDE)
Run Simulation 

Develop Integration Model
=====================================

Develop System Types and Data Dictionary
Develop Integration Constraints 

[Optional: Acceptance Tests, etc.]


Develop Component Implementations
============================================

Refine Port Types 



<Invariant: model integration is kept in sync>




Develop System Types and System Data Dictionary
============================================

Develop Types and Documentation
Development Constraints on Data (HAMR Contracts)
Develop Default Values and Other Value Sets used in Testing and Simulation

Develop Information Flow and Visualizations
============================================


Compute Entry Point -- Periodic Threads
-----------------------------------------

Following the structure presented in :ref:`ch04-hamr-aadl-fundamental-concepts`, for periodic AADL thread components the root of the primary application logic for the AADL compute entry point is the ``timeTriggered`` function.  This function will be repeatedly invoked by the underlying AADL and platform infrastructure at the rate corresponding to the ``Period`` property attached to the thread component in the AADL model.

HAMR generates a skeleton for the ``timeTriggered`` function (along with some other supporting functions) in the :file:`<component Cn>.c` as described above.  For the building control example, the following skeleton is generated in the file :file:`/ext-c/TempSensor_i_Impl/TempSensor_i_Impl.c` for the ``TempSensor`` periodic thread.  

.. code-block:: c

   Unit bc_BuildingControl_TempSensor_i_Impl_timeTriggered_(
         STACK_FRAME
         bc_BuildingControl_TempSensor_i_Impl this) {
     
         // Application code goes here
   }

Most HAMR C functions take a ``STACK_FRAME`` argument to support debugging and traceability back to the higher-level Slang infrastructure.  Developers don't need to manipulate this argument -- its values are populated by the underlying infrastructure.   Its use in debugging is discussed at the end of this chapter.  Most HAMR C functions associated with a component are passed a struct ``this`` that contains state information for the component.  This struct information never needs to be manipulated directly by application code.  It is created by HAMR initialization infrastructure code and then updated behind the scenes by each HAMR API call (further explanation is given at the end of the chapter).

.. note::

   **ToDo, From John, To Jason:** 
   
   * Check wording above

The completed application code for this example thread includes reading the sensor value by a call to the driver for the hardware temperature sensor.  The function uses HAMR-generated APIs in :file:`ext-c/TempSensor_i_Impl/TempSensor_i_Impl_api.*` to interact with AADL ports to send values out of the component output ports (the ``TempSensor`` component does not have input ports -- working with input ports is illustrated using the ``TempControl`` component in the section on sporadic threads below).

Since HAMR is designed for interoperability across multiple platforms and across programming languages including Slang and C, the function uses standardized macros and libaries for creation and access of type structures derived from AADL-level types and for other types (e.g., message strings used in logging) that are shared across Slang-supported infrastructure.

Comments in the code listing explain the use of the APIs and macros.

.. code-block:: c

   Unit bc_BuildingControl_TempSensor_i_Impl_timeTriggered_(
         STACK_FRAME
         bc_BuildingControl_TempSensor_i_Impl this) {

      // Use HAMR-provided macro to declare structure to hold temperature value retrieve via temp sensor driver         
      DeclNewbc_BuildingControl_Temperature_i(value);
      // Call driver function to move the temperature reading into the "value" structure
      currentTempGet(&value);

      // Use auto-generated APIs in ext-c/TempSensor_i_Impl/TempSensor_i_Impl_api.h to interact with AADL ports
      //  .. put current temp reading in "currentTemp" AADL out data port 
      api_send_currentTemp__bc_BuildingControl_TempSensor_i_Impl(this, &value);
      //  .. queue "tempChanged" event on "tempChanged" AADL out event port 
      api_send_tempChanged__bc_BuildingControl_TempSensor_i_Impl(this);

      // Use HAMR-provided macros to declare strings interoperable with Slang infrastructure. 
      DeclNewString(msg);
      String__append((String) &msg, string("Sensed temperature: "));
      // Prepare Slang compatible type structure for logging message
      bc_BuildingControl_Temperature_i_string_((String) &msg, &value);

      // send message structure to logger 
      api_logInfo__bc_BuildingControl_TempSensor_i_Impl(this, (String) &msg);

      // Recall: Following AADL semantics, all values placed in output ports using the "send" functions as above are held
      // until this function completes and are then propagated after this function completes to connected consumer 
      // components by the underlying AADL and platform infrastructure. 
   }


Compute Entry Point -- Sporadic Threads
-----------------------------------------

Following the structure presented in :ref:`ch04-hamr-aadl-fundamental-concepts`, for sporadic AADL thread components, the roots of the primary application logic for the AADL compute entry point are message handlers for input event and event data ports (more precisely, for input event and event data ports specified as dispatch triggers).

HAMR generates skeletons for message handlers for sporadic threads in the :file:`<component Cn>.c` as described above.  For the building control example, the following skeletons are generated in the file :file:`/ext-c/TempControl_i_Impl/TempControl_i_Impl.c` for the ``TempControl`` sporadic thread. 

.. code-block:: c

   // HAMR-generated skeleton for fanAck input event data port 
   Unit bc_BuildingControl_TempControl_i_Impl_handlefanAck_(
        STACK_FRAME
        bc_BuildingControl_TempControl_i_Impl this,
        // message payload for incoming event data 
        bc_BuildingControl_FanAck_Type value) {

        // Application code goes here
   }

   // HAMR-generated skeleton for fanAck input event data port 
   Unit bc_BuildingControl_TempControl_i_Impl_handlesetPoint_(
        STACK_FRAME
        bc_BuildingControl_TempControl_i_Impl this,
        // message payload for incoming event data 
        bc_BuildingControl_SetPoint_i value) {

       // Application code goes here
   }

   // HAMR-generated skeleton for tempChanged input event port 
   Unit bc_BuildingControl_TempControl_i_Impl_handletempChanged_(
        STACK_FRAME
        bc_BuildingControl_TempControl_i_Impl this) 
        // no message payload for input event ports (only payloads for event data ports)
                                                  {
       // Application code goes here
   }

Each of these message handlers is programmed in a manner similar to the ``timeTriggered`` function for periodic threads -- each handler uses HAMR-generated APIs in :file:`ext-c/TempControl_i_Impl/TempControl_i_Impl_api.*`.   For example, shown below is the implementation of the handler for the ``setPoint`` event data port, along with a variable declaration to store the incoming set points (so that the set point values persist and are accessible by the component across multiple dispatches).


.. code-block:: c

   // declare component local variable to store set point values 
   struct bc_BuildingControl_SetPoint_i setPoint;


   // completed implementation for setPoint input event data port handler
   Unit bc_BuildingControl_TempControl_i_Impl_handlesetPoint_(
         STACK_FRAME
         bc_BuildingControl_TempControl_i_Impl this,
         bc_BuildingControl_SetPoint_i value) {

      // copy the set point values to component-local state.  
      setPoint = *value;
   }

The handler implementation for the ``tempChanged`` *event* port is presented below.  Note that since AADL events are simple buffer notifications (with no message payloads), there is no payload value passed to the handler (in contrast to the handler for the *event data* port above).

.. code-block:: c

   Unit bc_BuildingControl_TempControl_i_Impl_handletempChanged_(
        STACK_FRAME
        bc_BuildingControl_TempControl_i_Impl this) {

       // Use Slang-transpiler macro for creating new strings 
       DeclNewString(msg);
       // Declare a local variable to hold the current temp structure 
       struct bc_BuildingControl_Temperature_i currentTemp;

       // Read the current temperature from the currentTemp data port.
       // Note that in AADL, data ports should always have values, so if the API has a false return value
       // then an error message is printed in the false branch of the conditional.
       if (api_get_currentTemp__bc_BuildingControl_TempControl_i_Impl(this, &currentTemp)) {
           
           // ToDo: From John, to Jason: I don't understand this step 
           struct bc_BuildingControl_Temperature_i tempInF = toFahrenheit(currentTemp);

           // compare the `degrees` field of the temperature structure to the high set point 
           if (tempInF.degrees > setPoint.high.degrees) {
               // if current temp exceeds the high set point, 
               // send a "fan on" command out of the fanCmd event data output port to cool environment
               api_send_fanCmd__bc_BuildingControl_TempControl_i_Impl(this, FanCmd_On);

               String__append((String) &msg, string("Sent fan command: "));
               bc_BuildingControl_FanCmd_Type_string_((String) &msg, FanCmd_On);
           }
           else if (tempInF.degrees < setPoint.low.degrees) {
               // if current temp is less than the low set point, 
               // send a "fan off" command out of the fanCmd event data output port to stop cooling environment

               api_send_fanCmd__bc_BuildingControl_TempControl_i_Impl(this, FanCmd_Off);

               String__append((String) &msg, string("Sent fan command: "));
               bc_BuildingControl_FanCmd_Type_string_((String) &msg, FanCmd_Off);
           }
           else {
               // if current temp is between high and low set points (inclusive)
               // don't change the on/off status of the fan 
               String__append((String) &msg, string("Temperature ok:"));
           }
           // creating a string that includes the current temperature for logging purposes 
           String__append((String) &msg, string(" - "));
           bc_BuildingControl_Temperature_i_string_((String) &msg, &currentTemp);

           api_logInfo__bc_BuildingControl_TempControl_i_Impl(this, (String) &msg);
       } else {
           printf("Unexpected: tempSensor should have also sent something on its currentTemp port\n");
       }
   }



Initialize Entry Point 
-----------------------

As described in :ref:`ch04-hamr-aadl-fundamental-concepts`, each AADL thread has an *initialize entry point* that is called during system initialization before system scheduling takes over the dispatching for all thread compute entry points.

The application developer fills in the code 



C APIs Domain APIs 




Finalize Entry Point
---------------------

(not fully implemented now)



Port Communication APIs
=========================

Following a structure similar to HAMR Slang code generation, for each AADL thread component, HAMR will generate APIs for interacting with the ports of the component.  The APIs generated for ``TempControl`` component are illustrated below.

.. code-block:: c

   /**********************************************************************************
   * fanCmd : out event data port FanCmd
   **********************************************************************************/

   Unit BuildingControl_TempControl_i_sendfanCmd(
         building_control_gen_mixed_excludes_BuildingControl_TempControl_i_Impl this,
         building_control_gen_mixed_excludes_BuildingControl_FanCmd value);


   /**********************************************************************************
   * currentTemp : in data port Temperature.i
   ***********************************************************************************/

   bool BuildingControl_TempControl_i_getcurrentTemp(
         building_control_gen_mixed_excludes_BuildingControl_TempControl_i_Impl this,
         building_control_gen_mixed_excludes_BuildingControl_Temperature_i value);

   /**********************************************************************************
   * tempChanged : in event port
   **********************************************************************************/

   bool BuildingControl_TempControl_i_gettempChanged(
         building_control_gen_mixed_excludes_BuildingControl_TempControl_i_Impl this,
         art_Empty value);

   /**********************************************************************************
   * fanAck : in event data port FanAck
   **********************************************************************************/

   bool BuildingControl_TempControl_i_getfanAck(
         building_control_gen_mixed_excludes_BuildingControl_TempControl_i_Impl this,
         building_control_gen_mixed_excludes_BuildingControl_FanAck *value);

   /**********************************************************************************
   * setPoint : in event data port SetPoint.i
   **********************************************************************************/

   bool BuildingControl_TempControl_i_getsetPoint(
         building_control_gen_mixed_excludes_BuildingControl_TempControl_i_Impl this,
         building_control_gen_mixed_excludes_BuildingControl_SetPoint_i value);

   /**********************************************************************************
   * logging methods
   **********************************************************************************/

   void BuildingControl_TempControl_i_logInfo(
         building_control_gen_mixed_excludes_BuildingControl_TempControl_i_Impl this,
         String str);

   void BuildingControl_TempControl_i_logDebug(
         building_control_gen_mixed_excludes_BuildingControl_TempControl_i_Impl this,
         String str);

   void BuildingControl_TempControl_i_logError(
         building_control_gen_mixed_excludes_BuildingControl_TempControl_i_Impl this,
         String str);

Each API is passed a struct ``this`` that contains state information about the component.  This struct information never needs to be manipulated directly by application code.  It is created by initialization infrastructure code and then updated behind the scenes by each HAMR API calls.

.. note::

   **ToDo, From John, To Jason:** 
   
   * Give the intuition of the ``this`` structure and indicate where the information for this structure is defined.
   

The design of the APIs above does not have the flavor of hand-written C code, but it is constructed in this way to enable the C code to interoperate with code generated for out HAMR component implementations written in Slang and CakeML.





In the API for ``out event data port`` ``sendfanCmd``,


.. code-block:: c

   Unit building_control_gen_mixed_excludes_BuildingControl_TempControl_i_Impl_handletempChanged_(
         STACK_FRAME
         building_control_gen_mixed_excludes_BuildingControl_TempControl_i_Impl this) {

      DeclNewString(msg);
      struct building_control_gen_mixed_excludes_BuildingControl_Temperature_i currentTemp;
      if (BuildingControl_TempControl_i_getcurrentTemp(this, &currentTemp)) {
         struct building_control_gen_mixed_excludes_BuildingControl_Temperature_i tempInF = toFahrenheit(currentTemp);

         if (tempInF.degrees > setPoint.high.degrees) {
               BuildingControl_TempControl_i_sendfanCmd(this, FanCmd_On);

               String__append((String) &msg, string("Sent fan command: "));
               building_control_gen_mixed_excludes_BuildingControl_FanCmd_string_((String) &msg, FanCmd_On);
         }
         else if (tempInF.degrees < setPoint.low.degrees) {
               BuildingControl_TempControl_i_sendfanCmd(this, FanCmd_Off);

               String__append((String) &msg, string("Sent fan command: "));
               building_control_gen_mixed_excludes_BuildingControl_FanCmd_string_((String) &msg, FanCmd_Off);
         }
         else {
               String__append((String) &msg, string("Temperature ok:"));
         }
         String__append((String) &msg, string(" - "));
         building_control_gen_mixed_excludes_BuildingControl_Temperature_i_string_((String) &msg, &currentTemp);
         BuildingControl_TempControl_i_logInfo(this, (String) &msg);
      } else {
         printf("Unexpected: tempSensor should have also sent something on its currentTemp port\n");
      }
   }



CMAKELists

STACK_FRAME

